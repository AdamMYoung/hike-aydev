{"version":3,"sources":["../../../node_modules/quickselect/index.js","../../../node_modules/rbush/index.js","../../../node_modules/@turf/helpers/dist/js/index.js","../../../node_modules/@turf/meta/dist/js/index.js","../../../node_modules/@turf/bbox/dist/js/index.js","../../../node_modules/geojson-rbush/index.js","../index.ts","../libs/prisma.ts","../libs/kv.ts","../libs/requests.ts","../activities/activities.ts","../../../node_modules/@turf/helpers/dist/es/index.js","../../../node_modules/@turf/invariant/dist/es/index.js","../../../node_modules/@turf/destination/dist/es/index.js","../../../node_modules/@turf/circle/dist/es/index.js","../../../node_modules/@turf/meta/dist/es/index.js","../../../node_modules/@turf/line-segment/dist/es/index.js","../../../node_modules/@turf/line-intersect/dist/es/index.js"],"sourcesContent":["\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = helpers.lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              helpers.lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return helpers.point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexports.coordAll = coordAll;\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.findPoint = findPoint;\nexports.findSegment = findSegment;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexports.default = bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","// ESM\nimport * as dotenv from \"dotenv\";\ndotenv.config();\n\nimport Fastify from \"fastify\";\nimport { routes as activities } from \"./activities\";\n\nconst fastify = Fastify({\n  logger: true,\n});\n\nfastify.register(activities);\n\n/**\n * Run the server!\n */\nconst start = async () => {\n  try {\n    await fastify.listen({ port: 3000 });\n  } catch (err) {\n    fastify.log.error(err);\n    process.exit(1);\n  }\n};\n\nstart();\n","import { PrismaClient } from \"database\";\n\nexport const prisma = new PrismaClient();\n","import kv from \"@vercel/kv\";\n\nexport const getCachedEntry = async <T extends unknown>(key: string, req: () => Promise<T>) => {\n  if (process.env.VERCEL_ENV !== \"production\") {\n    return req();\n  }\n\n  const stored = await kv.get<T>(key);\n\n  if (stored) {\n    return stored;\n  }\n\n  const request = await req();\n  await kv.set(key, request, { ex: 3600 });\n\n  return request;\n};\n","import { prisma } from \"./prisma\";\nimport { getCachedEntry } from \"./kv\";\n\nexport const getFellPoints = () => {\n  return getCachedEntry(\"get-fell-points\", () =>\n    prisma.fell.findMany({\n      select: {\n        id: true,\n        lat: true,\n        lng: true,\n        name: true,\n      },\n    })\n  );\n};\n","import { FastifyInstance, RouteShorthandOptions } from \"fastify\";\n\nimport { prisma } from \"../libs/prisma\";\nimport { getFellPoints } from \"../libs/requests\";\nimport { decode } from \"@googlemaps/polyline-codec\";\n\nimport circle from \"@turf/circle\";\nimport { lineString } from \"@turf/helpers\";\nimport lineIntersect from \"@turf/line-intersect\";\n\nconst stravaOpts: RouteShorthandOptions = {\n  schema: {\n    body: {\n      type: \"object\",\n      properties: {\n        polyline: { type: \"string\" },\n        owner_id: { type: \"number\" },\n      },\n    },\n  },\n};\n\nexport async function routes(fastify: FastifyInstance, options: object) {\n  fastify.post(\"/activities/manual\", async (request, reply) => {\n    return { hello: \"world\" };\n  });\n\n  fastify.post(\"/activities/strava\", stravaOpts, async (request, reply) => {\n    const { polyline, owner_id } = request.body as any;\n\n    const stravaAccount = await prisma.account.findUnique({\n      where: {\n        provider_providerAccountId: {\n          providerAccountId: owner_id.toString(),\n          provider: \"strava\",\n        },\n      },\n      select: {\n        access_token: true,\n        user: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n      },\n    });\n\n    if (!stravaAccount) {\n      reply.statusCode = 401;\n      reply.send();\n      return;\n    }\n\n    const decodedPolyline = decode(polyline);\n    const points = await getFellPoints();\n\n    const line = lineString(decodedPolyline);\n    const circles = points.map((c) => circle([c.lat, c.lng], 0.1, { properties: { id: c.id, name: c.name } }));\n\n    const intersectingCircles = circles.filter((c) => lineIntersect(c, line).features.length > 0);\n    const intersectingIds = intersectingCircles.map((c) => c.properties.id);\n\n    await prisma.logEntry.createMany({\n      skipDuplicates: true,\n      data: intersectingIds.map((id) => ({\n        fellId: id,\n        authorId: stravaAccount.user.id,\n        climbed: true,\n      })),\n    });\n\n    reply.send();\n  });\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n","import destination from \"@turf/destination\";\nimport { polygon, } from \"@turf/helpers\";\n/**\n * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.\n *\n * @name circle\n * @param {Feature<Point>|number[]} center center point\n * @param {number} radius radius of the circle\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} circle polygon\n * @example\n * var center = [-75.343, 39.984];\n * var radius = 5;\n * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};\n * var circle = turf.circle(center, radius, options);\n *\n * //addToMap\n * var addToMap = [turf.point(center), circle]\n */\nfunction circle(center, radius, options) {\n    if (options === void 0) { options = {}; }\n    // default params\n    var steps = options.steps || 64;\n    var properties = options.properties\n        ? options.properties\n        : !Array.isArray(center) && center.type === \"Feature\" && center.properties\n            ? center.properties\n            : {};\n    // main\n    var coordinates = [];\n    for (var i = 0; i < steps; i++) {\n        coordinates.push(destination(center, radius, (i * -360) / steps, options).geometry\n            .coordinates);\n    }\n    coordinates.push(coordinates[0]);\n    return polygon([coordinates], properties);\n}\nexport default circle;\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n"],"mappings":"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","names":["bbox","feature","point","lineString","polygon","isNumber","featureCollection","lengthToRadians","radiansToDegrees","degreesToRadians","isObject","bbox","require_js","featureEach","geomEach","flattenEach","bbox","feature","require_js","bbox","module","rbush","featureEach","polygon","featureCollection","feature","bbox","kv","bbox","feature","es_default","intersects","rbush","es_default","intersect","fastify","es_default","Fastify"]}